name: Workflow

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0-5 * * *'
    #- cron: '0/10 6-8 * * *'
    #- cron: '0/20 9-18 * * *'
    #- cron: '0/30 19-20 * * *'
    #- cron: '0 21-23 * * *'
  repository_dispatch:
    types: [trigger-name]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    # Generate json for shields.io Endpoint badge
    - name: Generate badge data
      id: badge_data
      run: |
        BADGE_VALUE=$(date -u +'%Y-%m-%d %H:%M:%SZ')
        JSON="guardian-news-last-run-badge.json"
        echo "json=$JSON" >> $GITHUB_OUTPUT
        cat <<EOF > $JSON
        {
          "schemaVersion": 1,
          "label": "last news update",
          "message": "$BADGE_VALUE",
          "color": "green"
        }
        EOF

    # Upload json from step badge_data 
    # to gist for shields.io Endpoint badge
    - name: Update gist run time badge
      uses: stellarhub/push-gist-action@v1
      with:
        token: ${{ secrets.GIST_TOKEN }}
        gist_id: "${{ vars.GIST_PERSISTANT_VARIABLE }}"
        file_path: ${{ steps.badge_data.outputs.json }}
        file_type: text

    - name: Get last fetch time
      id: get_last_fetch_time
      run: |
        # there may be seconds of delay for gist content update
        # gist_id is the url of the gist (e.g.) https://gist.github.com/<git username>/<gist_id>
        gist_id="${{ vars.GIST_PERSISTANT_VARIABLE }}"
        gist_filename="${{ vars.GIST_LAST_GUARDIAN_FETCH }}"

        api_url="https://api.github.com/gists/$gist_id"

        resp=$(curl -sSL -H "Authorization: token ${{ secrets.GIST_TOKEN_2025 }}" "$api_url")

        # echo "Gist response:"
        # echo "$resp" | jq .
        # echo "Files available in gist:"
        # echo "$resp" | jq -r '.files | keys[]'

        raw_url=$(echo "$resp" | jq -r ".files[\"$gist_filename\"].raw_url")

        if [ -z "$raw_url" ] || [ "$raw_url" = "null" ]; then
          echo "last=unknown" >> $GITHUB_OUTPUT
          exit 0
        fi

        # raw_url=$(curl -sSL "$api_url" | jq -r ".files[\"$gist_filename\"].raw_url")

        gist_content=$(curl -sSL "$raw_url")
        echo "last=$gist_content" >> $GITHUB_OUTPUT

    - name: Fetch Guardian content
      run: |
        API_KEY=${{ secrets.GUARDIAN_KEY }} 
        URL="https://content.guardianapis.com/search"
        ORDER_BY="newest"  
        PAGE_SIZE=200

        response=$(curl -s -G \
            --data-urlencode "api-key=$API_KEY" \
            --data-urlencode "order-by=$ORDER_BY" \
            --data-urlencode "page-size=$PAGE_SIZE" \
            "$URL")
        
        # for the response by publicationDate to process oldest items first
        # using order-by seems to have problem without specifying a date
        # which makes the logic more complex
        # format it as tsv for reading in the next step
        sorted_data=$(echo "$response" | jq -r '.response.results | sort_by(.webPublicationDate) | .[] | [.webPublicationDate, .sectionName, .pillarName, .type, .webTitle, .webUrl] | @tsv')

        # save response to a file due to size limit of GITHUB_OUTPUT
        echo "$sorted_data" > response.txt

    - name: Process Guardian content
      run: |
        current_time=$(date +"%s")
        sorted_data=$(cat response.txt)

        last_fetch=${{ steps.get_last_fetch_time.outputs.last }}
        last_fetch_formatted=$(date -d "@$last_fetch" +"%Y-%m-%d %H:%M:%SZ")
        printf "Last fetched message : %s (%s)\n" "$last_fetch_formatted" "$last_fetch" 

        seen_urls=""

        while IFS=$'\t' read -r webPublicationDate sectionName pillarName type webTitle webUrl; do
          pubunixtime=$(date -d "$webPublicationDate" "+%s")
          diff_minutes=$((($current_time - $pubunixtime) / 60))

          seen_urls=$(printf "%s\n%s" "$seen_urls" "$webUrl")

          if [ "$pubunixtime" -gt "$last_fetch" ]; then
            last_fetch=$pubunixtime

              case "$type" in
              article)
                status="new article"
                TZ='Europe/London'
                format="+%d %B, %H:%M UK time"
                formatted=$(TZ=$TZ date -d "@$pubunixtime" "$format")
                formatted=${formatted/#0/}

                count=$(grep -Fxc "$webUrl" <<< "$seen_urls")
                echo $count

                if [ "$count" -gt 1 ]; then
                  status="url found. updated post"
                else

                  shorturl=$(curl -s -d "format=simple&url=$webUrl" "https://is.gd/create.php")

                  GOOGLE_API_KEY=${{ secrets.GEMINI_API_KEY }} 
                  MODEL="gemini-2.5-flash"
                  # Build prompt for Gemini
                  text="Please translate the following into zh-TW (Traditional Chinese). Do not give pinyin.\n$webTitle"

                  # Call Gemini API
                  response=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${GOOGLE_API_KEY}" \
                    -H 'Content-Type: application/json' \
                    -d "{
                          \"contents\": [{
                            \"parts\": [
                              {\"text\": \"${text}\"}
                            ]
                          }]
                        }")

                  # Extract translated text
                  webTranslated=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text')

                  # Build Telegram message
                  tg_message=$(printf "%s\n%s/%s %s\n%s" \
                      "$formatted" \
                      "$sectionName" \
                      "$pillarName" \
                      "$shorturl" \
                      "$webTranslated" \
                      )

                  # tg_message=$(printf "%s\n%s/%s %s" "$formatted" "$sectionName" "$pillarName" "$shorturl")
                  tg_message=$(echo "$tg_message" | sed 's/ & / n /g')

                  status=$(printf "%s\nTG message: %s" "$status" "$tg_message")
                  #disable_preview="true"
                  disable_preview="false"
                  ##tg_response=$(curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_KEY }}/sendMessage" -d ##chat_id="${{ vars.TELEGRAM_CHANNEL_ID }}" -d text="$tg_message")

                  # Send the message with the link preview disabled
                  tg_response=$(curl -s -X POST \
                    "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_KEY }}/sendMessage" \
                    -d "chat_id=${{ vars.TELEGRAM_CHANNEL_ID }}" \
                    -d "text=$tg_message" \
                    -d "disable_web_page_preview=$disable_preview")
                fi
                ;;
              liveblog)
                status="ignore live blog"
                ;;
              crossword)
                status="ignore crossword type"
                ;;
              *)
                status="ignore unknown type"
                ;;
              esac

          else
            status="skip old message"
          fi

          printf "*** %s was %s minutes ago - %s ***\n%s\n" "$webPublicationDate" "$diff_minutes" "$status" "$webTitle"
        done < <(echo "$sorted_data")
        echo "last=$last_fetch" >> $GITHUB_OUTPUT
        echo "$last_fetch" > ${{ vars.GIST_LAST_GUARDIAN_FETCH }}
        printf "Seen urls:\n$s\n" "$seen_urls"

    - name: Push file to Gist
      uses: stellarhub/push-gist-action@v1
      with:
        token: ${{ secrets.GIST_TOKEN }}
        gist_id: "${{ vars.GIST_PERSISTANT_VARIABLE }}"
        file_path: ${{ vars.GIST_LAST_GUARDIAN_FETCH }}
        file_type: text
 
